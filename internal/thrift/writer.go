package thrift

import (
	"fmt"
	"io"

	"github.com/apache/thrift/lib/go/thrift"
	gothrift "github.com/apache/thrift/lib/go/thrift"
	"github.com/segmentio/parquet/internal/debug"
	"github.com/segmentio/parquet/internal/writers"
)

// Writer is a WriteSeeker that allows both marshalling Thrift structures and
// writing directly.
// It exclusively supports compact stream Thrift transports.
type Writer struct {
	w        writers.ForkWriteSeeker
	factory  *gothrift.TCompactProtocolFactory
	protocol gothrift.TProtocol
	size     int64 // sizeof the whole parquet file
}

// NewWriter constructs a thrift Writer from an existing io.WriteSeeker.
// No I/O is done at that point.
func NewWriter(w io.WriteSeeker) *Writer {
	writer := &Writer{
		w:       writers.NewShared(w),
		factory: thrift.NewTCompactProtocolFactory(),
	}
	return writer
}

// Marshalable should be respected by all structs generated by Thrift.
type Marshalable interface {
	Write(iprot gothrift.TProtocol) error
}

// Open the thrift file for writing.
// Seeks to the end of the file to assess its size.
// TODO: this seek will be an issue when reading an S3 file.
func (tw *Writer) Open() error {
	debug.Format("parquet.Writer: Open: end seek")
	size, err := tw.w.Seek(0, io.SeekEnd)
	if err != nil {
		return fmt.Errorf("unexpected seek end error: %w", err)
	}
	debug.Format("parquet.Writer: Open: start seek")
	_, err = tw.w.Seek(0, io.SeekStart)
	if err != nil {
		return fmt.Errorf("unexpected seek start error: %w", err)
	}
	tw.size = size
	debug.Format("parquet.Reader: size: %d", tw.size)
	tw.resetProtocol()
	return nil
}

// Fork creates a copy of this Reader, with a new state, but sharing the
// underlying ReadSeeker.
func (tw *Writer) Fork() *Writer {
	return &Writer{
		w: tw.w.Fork(),
		// thrift's factory should be shareable, no need to re-create it
		factory: tw.factory,
	}
}

// Write implements the io.Writer interface, forwarding the call to the
// underlying Thrift protocol Writer.
func (tw *Writer) Write(p []byte) (int, error) {
	debug.Format("thrift: Writer: write %d", len(p))
	return tw.protocol.Transport().Write(p)
}

// Seek implements the io.Seeker interface, which the same expectations for
// whence amd return values.
func (tw *Writer) Seek(offset int64, whence int) (int64, error) {
	n, err := tw.w.Seek(offset, whence)
	if err != nil {
		return 0, err
	}

	// seems like before every thrift read we need to make a new thrift reader
	// because it does not handle the underlying reader to seek around?
	tw.resetProtocol()
	return n, nil
}

// Marshal a Thrift struct n write using underlying writer
func (tw *Writer) Marshal(u Marshalable) error {
	debug.Format("thrift: Reader: unmarshal %v", u)
	err := u.Write(tw.protocol)
	return err
}

func (tw *Writer) resetProtocol() {
	debug.Format("thrift: Writer: resetProtocol")
	if tw.protocol != nil {
		err := tw.protocol.Transport().Close()
		if err != nil {
			debug.Format("thrift: Writer: resetProtocol: closing transport: %s", err)
		}
	}
	thriftWriter := thrift.NewStreamTransportW(tw.w)
	bufferWriter := thrift.NewTBufferedTransport(thriftWriter, int(tw.size))
	tw.protocol = thrift.NewTCompactProtocol(bufferWriter)
}
