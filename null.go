//go:build go1.18

package parquet

import (
	"bytes"
	"reflect"
	"unsafe"

	"github.com/segmentio/parquet-go/deprecated"
)

// nullIndexFunc is the type of functions generated by calling nullIndexFuncOf.
//
// The function takes an array of values that it assumes the type of (based on
// the reflect.Type that it was created from) and returns the index of the first
// null value, or the length of the array if no values were null.
//
// A value is null if it is zero for number types, or if it is nil for a slice
// type. Struct values are never null.
type nullIndexFunc func(array) int

func nullIndexBool(a array) int {
	i := bytes.IndexByte(makeSlice[byte](a), 0)
	if i < 0 {
		i = a.len
	}
	return i
}

func nullIndexInt96(a array) int {
	for i, v := range unsafe.Slice((*deprecated.Int96)(a.ptr), a.len) {
		if v == (deprecated.Int96{}) {
			return i
		}
	}
	return a.len
}

func nullIndexString(a array) int {
	for i := 0; i < a.len; i++ {
		p := *(*string)(a.index(i, unsafe.Sizeof(""), 0))
		if p == "" {
			return i
		}
	}
	return a.len
}

func nullIndexSlice(a array) int {
	const size = unsafe.Sizeof(([]struct{})(nil))
	for i := 0; i < a.len; i++ {
		p := *(*unsafe.Pointer)(a.index(i, size, 0))
		if p == nil {
			return i
		}
	}
	return a.len
}

func nullIndexFuncOf(t reflect.Type) nullIndexFunc {
	switch t {
	case reflect.TypeOf(deprecated.Int96{}):
		return nullIndexInt96
	}

	switch t.Kind() {
	case reflect.Bool:
		return nullIndexBool

	case reflect.Int:
		return nullIndexInt

	case reflect.Int32:
		return nullIndexInt32

	case reflect.Int64:
		return nullIndexInt64

	case reflect.Uint:
		return nullIndexUint

	case reflect.Uint32:
		return nullIndexUint32

	case reflect.Uint64:
		return nullIndexUint64

	case reflect.Float32:
		return nullIndexFloat32

	case reflect.Float64:
		return nullIndexFloat64

	case reflect.String:
		return nullIndexString

	case reflect.Slice:
		return nullIndexSlice

	case reflect.Array:
		if t.Elem().Kind() == reflect.Uint8 {
			switch size := t.Len(); size {
			case 16:
				return nullIndexOfUint128
			default:
				return nullIndexFuncOfByteArray(size)
			}
		}

	case reflect.Pointer:
		return nullIndexPointer

	case reflect.Struct:
		return func(a array) int { return a.len }
	}

	panic("cannot convert Go values of type " + t.String() + " to parquet value")
}

func nullIndexFuncOfByteArray(size int) nullIndexFunc {
	return func(a array) int {
		for i := 0; i < a.len; i++ {
			p := a.index(i, uintptr(size), 0)
			b := slice[byte](p, size)
			if bytes.Count(b, []byte{0}) == len(b) {
				return i
			}
		}
		return a.len
	}
}

// nonNullIndexFunc is the type of functions generated by calling
// nonNullIndexFuncOf.
//
// The function takes an array of values that it assumes the type of (based on
// the reflect.Type that it was created from) and returns the index of the first
// non-null value, or the length of the array if all values were null.
//
// A value is null if it is zero for number types, or if it is nil for a slice
// type. Struct values are never null.
type nonNullIndexFunc func(array) int

func nonNullIndexSlice(a array) int {
	const size = unsafe.Sizeof(([]byte)(nil))
	for i := 0; i < a.len; i++ {
		p := *(*unsafe.Pointer)(a.index(i, size, 0))
		if p != nil {
			return i
		}
	}
	return a.len
}

func nonNullIndex[T comparable](a array) int {
	var zero T
	for i, v := range makeSlice[T](a) {
		if v != zero {
			return i
		}
	}
	return a.len
}

func nonNullIndexFuncOf(t reflect.Type) nonNullIndexFunc {
	switch t {
	case reflect.TypeOf(deprecated.Int96{}):
		return nonNullIndex[deprecated.Int96]
	}

	switch t.Kind() {
	case reflect.Bool:
		return nonNullIndex[bool]

	case reflect.Int, reflect.Uint:
		return nonNullIndex[int]

	case reflect.Int8, reflect.Uint8:
		return nonNullIndex[int8]

	case reflect.Int16, reflect.Uint16:
		return nonNullIndex[int16]

	case reflect.Int32, reflect.Uint32:
		return nonNullIndex[int32]

	case reflect.Int64, reflect.Uint64:
		return nonNullIndex[int64]

	case reflect.Float32:
		return nonNullIndex[float32]

	case reflect.Float64:
		return nonNullIndex[float64]

	case reflect.String:
		return nonNullIndex[string]

	case reflect.Slice:
		return nonNullIndexSlice

	case reflect.Array:
		if t.Elem().Kind() == reflect.Uint8 {
			return nonNullIndexFuncOfArray(t)
		}

	case reflect.Pointer:
		return nonNullIndex[unsafe.Pointer]

	case reflect.Struct:
		return func(array) int { return 0 }
	}

	panic("cannot convert Go values of type " + t.String() + " to parquet value")
}

func nonNullIndexFuncOfArray(t reflect.Type) nonNullIndexFunc {
	arrayLen := t.Len()
	return func(a array) int {
		for i := 0; i < a.len; i++ {
			p := a.index(i, uintptr(arrayLen), 0)
			b := slice[byte](p, arrayLen)
			if bytes.Count(b, []byte{0}) != len(b) {
				return i
			}
		}
		return a.len
	}
}
