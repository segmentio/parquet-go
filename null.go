//go:build go1.18

package parquet

import (
	"bytes"
	"reflect"
	"unsafe"

	"github.com/segmentio/parquet-go/deprecated"
)

type nullBitsFunc func(bits []uint64, rows array, size, offset uintptr)

func nullBits[T comparable](bits []uint64, rows array, size, offset uintptr) {
	var zero T

	i := 0
	n := (rows.len + 63) / 64

	for i < n {
		b := uint64(0)

		for j := 0; j < 64; j++ {
			v := *(*T)(rows.index(i, size, offset))
			x := uint64(0)
			if v != zero {
				x = 1
			}
			b |= x << uint(j)
		}

		bits[i/64] = b
		i += 64
	}

	b := uint64(0)
	for i < rows.len {
		v := *(*T)(rows.index(i, size, offset))
		x := uint64(0)
		if v != zero {
			x = 1
		}
		b |= x << uint(i%64)
		i++
	}

	bits[i/64] = b
}

func nullBitsSlice(bits []uint64, rows array, size, offset uintptr) {
	for i := 0; i < rows.len; i++ {
		p := *(**struct{})(rows.index(i, size, offset))
		b := uint64(0)
		if p != nil {
			b = 1
		}
		bits[uint(i)/64] |= b << (uint(i) % 64)
	}
}

func nullBitsStruct(bits []uint64, rows array, size, offset uintptr) {
	for i := range bits {
		bits[i] = 0
	}
}

func nullBitsFuncOf(t reflect.Type) nullBitsFunc {
	switch t.Kind() {
	case reflect.Bool:
		return nullBits[bool]

	case reflect.Int:
		return nullBits[int]

	case reflect.Int32:
		return nullBits[int32]

	case reflect.Int64:
		return nullBits[int64]

	case reflect.Uint:
		return nullBits[uint]

	case reflect.Uint32:
		return nullBits[uint32]

	case reflect.Uint64:
		return nullBits[uint64]

	case reflect.Float32:
		return nullBits[float32]

	case reflect.Float64:
		return nullBits[float64]

	case reflect.String:
		return nullBits[string]

	case reflect.Slice:
		return nullBitsSlice

	case reflect.Array:
		if t.Elem().Kind() == reflect.Uint8 {
			switch size := t.Len(); size {
			case 16:
				return nullBits[[16]byte]
			default:
				return nullBitsFuncOfByteArray(size)
			}
		}

	case reflect.Pointer:
		return nullBits[*struct{}]

	case reflect.Struct:
		return nullBitsStruct
	}

	panic("cannot convert Go values of type " + t.String() + " to parquet value")
}

func nullBitsFuncOfByteArray(n int) nullBitsFunc {
	return func(bits []uint64, rows array, size, offset uintptr) {
		for i := 0; i < rows.len; i++ {
			a := array{
				ptr: rows.index(i, size, offset),
				len: n,
			}
			for j := 0; j < n; j++ {
				x := uint(i+j) / 64
				y := uint(i+j) % 64
				b := uint64(0)
				if *(*byte)(a.index(j, uintptr(n), 0)) != 0 {
					b = 1
				}
				bits[x] |= b << y
			}
		}
	}
}

// nullIndexFunc is the type of functions generated by calling nullIndexFuncOf.
//
// The function takes an array of values that it assumes the type of (based on
// the reflect.Type that it was created from) and returns the index of the first
// null value, or the length of the array if no values were null.
//
// A value is null if it is zero for number types, or if it is nil for a slice
// type. Struct values are never null.
type nullIndexFunc func(array) int

func nullIndex[T comparable](a array) int {
	var zero T
	for i, v := range makeSlice[T](a) {
		if v == zero {
			return i
		}
	}
	return a.len
}

func nullIndexBool(a array) int {
	i := bytes.IndexByte(makeSlice[byte](a), 0)
	if i < 0 {
		i = a.len
	}
	return i
}

func nullIndexInt96(a array) int {
	return nullIndex[deprecated.Int96](a)
}

func nullIndexString(a array) int {
	return nullIndex[string](a)
}

func nullIndexSlice(a array) int {
	const size = unsafe.Sizeof(([]struct{})(nil))
	for i := 0; i < a.len; i++ {
		p := *(*unsafe.Pointer)(a.index(i, size, 0))
		if p == nil {
			return i
		}
	}
	return a.len
}

func nullIndexFuncOf(t reflect.Type) nullIndexFunc {
	switch t {
	case reflect.TypeOf(deprecated.Int96{}):
		return nullIndexInt96
	}

	switch t.Kind() {
	case reflect.Bool:
		return nullIndexBool

	case reflect.Int:
		return nullIndexInt

	case reflect.Int32:
		return nullIndexInt32

	case reflect.Int64:
		return nullIndexInt64

	case reflect.Uint:
		return nullIndexUint

	case reflect.Uint32:
		return nullIndexUint32

	case reflect.Uint64:
		return nullIndexUint64

	case reflect.Float32:
		return nullIndexFloat32

	case reflect.Float64:
		return nullIndexFloat64

	case reflect.String:
		return nullIndexString

	case reflect.Slice:
		return nullIndexSlice

	case reflect.Array:
		if t.Elem().Kind() == reflect.Uint8 {
			switch size := t.Len(); size {
			case 16:
				return nullIndexOfUint128
			default:
				return nullIndexFuncOfByteArray(size)
			}
		}

	case reflect.Pointer:
		return nullIndexPointer

	case reflect.Struct:
		return func(a array) int { return a.len }
	}

	panic("cannot convert Go values of type " + t.String() + " to parquet value")
}

func nullIndexFuncOfByteArray(size int) nullIndexFunc {
	return func(a array) int {
		for i := 0; i < a.len; i++ {
			p := a.index(i, uintptr(size), 0)
			b := slice[byte](p, size)
			if bytes.Count(b, []byte{0}) == len(b) {
				return i
			}
		}
		return a.len
	}
}

// nonNullIndexFunc is the type of functions generated by calling
// nonNullIndexFuncOf.
//
// The function takes an array of values that it assumes the type of (based on
// the reflect.Type that it was created from) and returns the index of the first
// non-null value, or the length of the array if all values were null.
//
// A value is null if it is zero for number types, or if it is nil for a slice
// type. Struct values are never null.
type nonNullIndexFunc func(array) int

func nonNullIndex[T comparable](a array) int {
	var zero T
	for i, v := range makeSlice[T](a) {
		if v != zero {
			return i
		}
	}
	return a.len
}

func nonNullIndexInt96(a array) int { return nonNullIndex[deprecated.Int96](a) }

func nonNullIndexString(a array) int { return nonNullIndex[string](a) }

func nonNullIndexSlice(a array) int {
	const size = unsafe.Sizeof(([]struct{})(nil))
	for i := 0; i < a.len; i++ {
		p := *(*unsafe.Pointer)(a.index(i, size, 0))
		if p != nil {
			return i
		}
	}
	return a.len
}

func nonNullIndexFuncOf(t reflect.Type) nonNullIndexFunc {
	switch t {
	case reflect.TypeOf(deprecated.Int96{}):
		return nonNullIndexInt96
	}

	switch t.Kind() {
	case reflect.Bool:
		return nonNullIndexBool

	case reflect.Int, reflect.Uint:
		return nonNullIndexInt

	case reflect.Int32:
		return nonNullIndexInt32

	case reflect.Int64:
		return nonNullIndexInt64

	case reflect.Uint32:
		return nonNullIndexUint32

	case reflect.Uint64:
		return nonNullIndexUint64

	case reflect.Float32:
		return nonNullIndexFloat32

	case reflect.Float64:
		return nonNullIndexFloat64

	case reflect.String:
		return nonNullIndexString

	case reflect.Slice:
		return nonNullIndexSlice

	case reflect.Array:
		if t.Elem().Kind() == reflect.Uint8 {
			switch size := t.Len(); size {
			case 16:
				return nonNullIndexUint128
			default:
				return nonNullIndexFuncOfArray(size)
			}
		}

	case reflect.Pointer:
		return nonNullIndexPointer

	case reflect.Struct:
		return func(array) int { return 0 }
	}

	panic("cannot convert Go values of type " + t.String() + " to parquet value")
}

func nonNullIndexFuncOfArray(size int) nonNullIndexFunc {
	return func(a array) int {
		for i := 0; i < a.len; i++ {
			p := a.index(i, uintptr(size), 0)
			b := slice[byte](p, size)
			if bytes.Count(b, []byte{0}) != len(b) {
				return i
			}
		}
		return a.len
	}
}
